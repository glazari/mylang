global x: u64 = 7 + 5;
global y: u64 = x + 35 + x;
global z: u64 = y + x;

fn main() -> u64 {
  print_numberln(x);
  print_numberln(y);
  print_numberln(z);

  // can mutate globals
  x = 32;
  print_numberln(x);

  // does not alter derived globals
  print_numberln(z);
}



// --------------------------------------------------------------------------------
// prelude, like area, helper functions
// --------------------------------------------------------------------------------

fn print_numberln(num: u64) -> u64 {
  let num_size: u64 = 0;
  let cp_num: u64 = num;
  while (cp_num > 0) {
    cp_num = cp_num / 10;
    num_size = num_size + 1;
  }
  let digit: u64 = 0;
  let base: u64 = 0;

  while (num > 0) {
    base = pow(10, num_size-1);
    digit = num / base + 48;
    print_chr(digit);
    num = num % base;
    num_size = num_size - 1;
  } 
  print_chr(10);
}

fn pow(base: u64, exp: u64) -> u64 {
  let prod: u64 = 1;
  while (exp > 0) {
    prod = prod * base;
    exp = exp - 1;
  }
  return prod;
}

fn print_chr(a: u64) -> u64 {
  asm {
    mov rsi, rbp
    add rsi, 24 ; point to address of a
    mov rdx, 1 ; length
    mov rax, 1 ; write syscall
    mov rdi, 1 ; stdout file handle
    syscall
  }
}
